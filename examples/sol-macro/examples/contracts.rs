//! Example showing how to interact with a contract using the sol macro
use alloy::{node_bindings::Anvil, providers::ProviderBuilder, sol};
use eyre::Result;
use futures_util::StreamExt;

// Generate a contract instance from Solidity.
// Note the sol attributes `rpc` and `bytecode` (creation code). This attributes create methods for
// us to interact and deploy the contract respectively. Removing these attributes will not let you
// interact with or deploy the contract. It will only create rust types for the contract.
sol!(
    #[allow(missing_docs)]
    #[sol(rpc, bytecode = "0x60808060405234610019575f8055610143908161001e8239f35b5f80fdfe60806040526004361015610011575f80fd5b5f3560e01c80632baeceb7146100c357806361bc221a146100a75763d09de08a1461003a575f80fd5b346100a3575f3660031901126100a3575f5460018101905f60018312911290801582169115161761008f57805f55337ff6d1d8d205b41f9fb9549900a8dba5d669d68117a3a2b88c1ebc61163e8117ba5f80a3005b634e487b7160e01b5f52601160045260245ffd5b5f80fd5b346100a3575f3660031901126100a35760205f54604051908152f35b346100a3575f3660031901126100a3575f545f19810190811360011661008f57805f55337fdc69c403b972fc566a14058b3b18e1513da476de6ac475716e489fae0cbe4a265f80a300fea2646970667358221220c045c027059726f9175a4abd427eb3f7a3fe8e27108bc19e4ae46055e7c1842c64736f6c63430008180033")]
    contract Counter {
        int256 public counter = 0;

        event Increment(address indexed by, int256 indexed value);
        event Decrement(address indexed by, int256 indexed value);

        function increment() public {
            counter += 1;
            emit Increment(msg.sender, counter);
        }

        function decrement() public {
            counter -= 1;
            emit Decrement(msg.sender, counter);
        }
    }
);

#[tokio::main]
async fn main() -> Result<()> {
    // Spin up a local Anvil node.
    let anvil = Anvil::new().try_spawn()?;

    // Set up signer from the first default Anvil account.
    let _signer = anvil.keys()[0].clone();

    // Create a provider with the signer.
    let rpc_url = anvil.endpoint().parse()?;
    let provider = ProviderBuilder::new().with_gas_estimation().on_http(rpc_url);

    // Deploy the `Counter` contract.
    let contract = Counter::deploy(provider.clone()).await?;

    // Watch the `Increment` event.
    let incr_event = contract.Increment_filter().watch().await?;
    // Call the `increment` function using a simple yet powerful API generated by the sol macro.
    let incr_call = contract.increment();
    let _send = incr_call.send().await?;

    // Read the counter value after incrementing.
    let new_val_call = contract.counter();
    let new_counter_val = new_val_call.call().await?;

    println!("Counter value after increment: {}", new_counter_val._0);

    let stream = incr_event.into_stream().take(1);

    let _s = stream
        .for_each(|log| async {
            let (increment, _log_info) = log.unwrap();
            println!("Increment event: by: {}, value: {}", increment.by, increment.value);
        })
        .await;

    Ok(())
}
